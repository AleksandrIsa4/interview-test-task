## Тестовое задание
### Описание
Существует некая система **X**, в этой системе  
периодически запускаются какие-то **процессы**,  
у каждого **процесса** есть идентификатор `processId`  
в ходе жизни процесс меняет своё состояние согласно этому графу:
![IMG](./img/graphviz.png)  
> START1 имеет приоритет над START2  
> FINAL1 имеет приоритет над FINAL2 
  
Наша система **Y** подписана на получение событий  
по смене состояния процессов, однако  
в системе **X** модуль уведомления работает со сбоями  
и может посылать нам уведомления в неверном порядке  
  
Поэтому мы решили в течение N времени собирать все уведомления,    
формировать из них согласованный список и обрабатывать,  
и повторять этот процесс до тех пор пока не дойдем до финального  
уведомления  

### Что требуется
Нашей задачей является сделать такой аккумулятор уведомлений,  
который сможет принимать **несоответствующий графу** список уведомлений  
и отдавать обратно **соответствующий графу список**.  
**Итоговый список** должен соблюдать эти условия:
- Уведомление, которое пришло раньше(`seqNo`), должно обладать меньшим индексом в итоговом списке
- Более приоритетное уведомление должно обработаться раньше независимо от порядка прихода  
*если у `START2 seqNo=1` а у `START1 seqNo=2` то на обработку пойдет `START1`*
- Список должен быть максимально возможной длины с учетом пришедших уведомлений на момент его формирования
- Одно и то же уведомление(`seqNo`) не должно попадать дважды в итоговый список
- Если было обработано финальное уведомление то никакие уведомления больше не должны быть обработаны

### Пример
На примере одного процесса, в собках указан номер уведомления:  
Пришло: `FINAL2(1), MID2(2), START1(3), MID1(4), MID2(5), FINAL1(6)`  
Что выдаст аккумулятор: `START1(3), MID1(4), MID2(2), FINAL1(6)`  

### О классах
О классах написано в `JavaDoc`  

### Проверка
Для проверки используется `AccumulatorTest`,  
в нем определено несколько тестовых сценариев